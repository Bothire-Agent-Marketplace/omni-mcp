---
description:
globs:
alwaysApply: false
---
# TypeScript Rules

## üîß **Strict Configuration (MANDATORY)**
- **ALL TypeScript configs MUST extend** `tsconfig.base.json`
- **Enable strict mode** for type safety
- **Use proper module resolution** for imports
- **No TypeScript errors allowed** in commits

```json
// ‚úÖ CORRECT - Server tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["dist", "node_modules"]
}
```

## üì¶ **Import/Export Patterns**

### **Shared Types (MANDATORY)**
```typescript
// ‚úÖ CORRECT - Use package imports for shared types
import { McpResponse, ToolDefinition, LinearIssue } from "@mcp/schemas";

// ‚ùå WRONG - Don't use relative imports for shared code
import { Tool } from "../../../shared/schemas/src/mcp/types";
```

### **Local Imports**
```typescript
// ‚úÖ CORRECT - Use relative imports for local modules
import { LinearTools } from "./tools/linear-tools.js";
import { LINEAR_CONFIG } from "../config/config.js";
```

### **File Extensions**
- **Use `.js` extensions** in import statements (TypeScript requirement)
- **Export both types and runtime values** when needed

## üéØ **Type Safety Patterns**

### **Generic Types**
```typescript
// ‚úÖ CORRECT - Proper generic typing
async function execute<T>(
  operation: () => Promise<T>
): Promise<McpResponse<T>> {
  try {
    const data = await operation();
    return { success: true, data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}
```

### **Type Guards**
```typescript
// ‚úÖ CORRECT - Use type guards for runtime validation
function isLinearIssue(data: unknown): data is LinearIssue {
  return LinearIssueSchema.safeParse(data).success;
}
```

### **Async/Await Patterns**
```typescript
// ‚úÖ CORRECT - Proper async error handling
async function fetchIssues(args: SearchIssuesArgs): Promise<McpResponse<IssueList>> {
  try {
    const issues = await this.client.issues(args);
    const formattedIssues = await Promise.all(
      issues.nodes.map(async (issue) => ({
        id: issue.id,
        title: issue.title,
        state: (await issue.state)?.name,
      }))
    );
    return { success: true, data: { issues: formattedIssues } };
  } catch (error) {
    return { success: false, error: error.message };
  }
}
```

## üìã **Code Quality Rules**

### **Type Annotations**
- **Always type function parameters** and return types
- **Use explicit return types** for public functions
- **Avoid `any`** unless absolutely necessary (document why)

### **Interface vs Type**
```typescript
// ‚úÖ CORRECT - Use interfaces for extensible object shapes
interface McpServerConfig {
  name: string;
  version: string;
  capabilities: ServerCapabilities;
}

// ‚úÖ CORRECT - Use types for unions and computed types
type McpResponse<T> = McpSuccessResponse<T> | McpErrorResponse;
```

### **Readonly Patterns**
```typescript
// ‚úÖ CORRECT - Use readonly for immutable data
export const LINEAR_TOOLS: readonly ToolDefinition[] = [
  // ... definitions
] as const;
```

## üö´ **TypeScript Anti-Patterns**
- ‚ùå Don't use `any` without documentation
- ‚ùå Don't ignore TypeScript errors (fix them)
- ‚ùå Don't skip return type annotations on public functions
- ‚ùå Don't use non-null assertions (`!`) without strong justification
- ‚ùå Don't mix ES modules and CommonJS patterns

## üîß **Development Workflow**
- **Run type checking** before commits: `tsc --noEmit`
- **Use strict mode** in all configurations
- **Enable all strict flags** in tsconfig.base.json
- **Use workspace references** for multi-package builds
